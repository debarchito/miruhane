<script lang="ts">
  import { onMount } from "svelte";
  import { writable, get } from "svelte/store";
  import AppSidebar from "$lib/components/app-sidebar.svelte";
  import * as Breadcrumb from "$lib/components/ui/breadcrumb/index.js";
  import { Separator } from "$lib/components/ui/separator/index.js";
  import * as Sidebar from "$lib/components/ui/sidebar/index.js";
  import { Mic, MicOff, Send } from "lucide-svelte";

  // Define writable stores with proper types
  const isSpeaking = writable<boolean>(false);
  const isRecording = writable<boolean>(false);
  const showSubtitles = writable<boolean>(true);
  const scale = writable<number>(1);
  const textToSpeak = writable<string>("Awaiting your input...");
  const userInput = writable<string>(""); // Stores user input (recorded or typed)
  const isLoading = writable<boolean>(false);

  // Define types for variables
  let speechRecognition: Window["SpeechRecognition"] | null = null;
  let shouldContinueRecording = false;

  const startRecording = (): void => {
    if (speechRecognition && !get(isRecording)) {
      console.log("Starting recording...");
      isRecording.set(true);
      shouldContinueRecording = true;
      userInput.set(""); // Clear any previous input
      speechRecognition.start();
    }
  };

  const stopRecording = (): void => {
    if (speechRecognition && get(isRecording)) {
      console.log("Stopping recording...");
      isRecording.set(false);
      shouldContinueRecording = false;
      speechRecognition.stop();
    }
  };

  onMount(() => {
    if ("SpeechRecognition" in window || "webkitSpeechRecognition" in window) {
      speechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      speechRecognition.lang = "en-US";
      speechRecognition.interimResults = true;

      speechRecognition.onresult = (event: SpeechRecognitionEvent): void => {
        let transcript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          transcript += event.results[i][0].transcript;
        }

        if (event.results[event.resultIndex].isFinal) {
          console.log("Final recognized speech:", transcript.trim());
          // Concatenate the final transcript with the previous input
          userInput.update((prevInput) => prevInput + " " + transcript.trim());
        }
      };

      speechRecognition.onerror = (event: SpeechRecognitionErrorEvent): void => {
        console.error("SpeechRecognition error:", event.error);
        stopRecording();
      };

      speechRecognition.onend = (): void => {
        console.log("SpeechRecognition ended.");
        if (shouldContinueRecording) {
          console.log("Restarting recording...");
          speechRecognition?.start();
        }
      };

      console.log("SpeechRecognition initialized.");
    } else {
      console.error("SpeechRecognition is not supported in this browser.");
      textToSpeak.set("Your browser does not support SpeechRecognition.");
    }
  });

  const handleSubmit = async (): Promise<void> => {
    const query = get(userInput).trim();
    if (query) {
      console.log("Query sent to Gemini AI:", query);
      const answer = await getGeminiAnswer(query);
      textToSpeak.set(answer);
      if (get(showSubtitles)) {
        speak(answer);
      }
    }
  };

  const getGeminiAnswer = async (query: string): Promise<string> => {
    const apiKey = "YOUR_GEMINI_API_KEY"; // Replace with your actual API key
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;

    const requestBody = {
      contents: [
        {
          parts: [{ text: query }],
        },
      ],
    };

    try {
      isLoading.set(true); // Indicate loading state

      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(requestBody), // Send the request payload
      });

      if (!response.ok) {
        console.error("Error response from Gemini API:", response.statusText);
        return `Error: ${response.statusText}`;
      }

      const data = await response.json();
      isLoading.set(false); // Turn off loading state

      // Log the raw API response for debugging
      console.log("Raw API Response:", data);

      // Safely extract and return the generated content
      if (data?.candidates?.length > 0 && data.candidates[0]?.content?.parts?.[0]?.text) {
        return data.candidates[0].content.parts[0].text; // Return the text generated by Gemini
      } else {
        return "No valid content found in the response.";
      }
    } catch (error) {
      console.error("Error fetching from Gemini API:", error);
      isLoading.set(false); // Turn off loading state
      return "There was an error processing your request. Please try again.";
    }
  };

  const speak = (text: string): void => {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.onstart = (): void => {
      isSpeaking.set(true);
      scale.set(1.2);
    };
    utterance.onend = (): void => {
      isSpeaking.set(false);
      scale.set(1);
    };
    speechSynthesis.speak(utterance);
  };
</script>

<Sidebar.Provider>
  <AppSidebar />
  <Sidebar.Inset>
    <header class="flex h-16 shrink-0 items-center gap-2">
      <div class="flex items-center gap-2 px-4">
        <Sidebar.Trigger class="-ml-1" />
        <Separator orientation="vertical" class="mr-2 h-4" />
        <Breadcrumb.Root>
          <Breadcrumb.List>
            <Breadcrumb.Item class="hidden md:block">
              <Breadcrumb.Link href="#">AI Interface</Breadcrumb.Link>
            </Breadcrumb.Item>
            <Breadcrumb.Separator class="hidden md:block" />
            <Breadcrumb.Item>
              <Breadcrumb.Page>Visualizer</Breadcrumb.Page>
            </Breadcrumb.Item>
          </Breadcrumb.List>
        </Breadcrumb.Root>
      </div>
    </header>
    <div class="page-wrapper">
      <div class="visualizer" aria-hidden="true" style="transform: scale({$scale});">
        <div class="center-circle"></div>
      </div>

      <div class="input-container">
        <button
          onclick={$isRecording ? stopRecording : startRecording}
          class="rounded-full p-2 text-white shadow-md hover:bg-opacity-90"
          style="background-color: {$isRecording ? 'red' : '#4f46e5'};"
        >
          {#if $isRecording}
            <MicOff />
          {:else}
            <Mic />
          {/if}
        </button>
        <input
          type="text"
          class="flex-1 rounded-lg border-gray-300 px-4 py-2 shadow-md"
          placeholder="Type your query..."
          bind:value={$userInput}
        />
        <button
          onclick={handleSubmit}
          class="flex items-center gap-2 rounded-lg bg-green-600 px-4 py-2 text-white shadow-md hover:bg-green-700"
          disabled={$isRecording}
        >
          <Send /> Send
        </button>
      </div>

      {#if $showSubtitles}
        <div class="subtitles mt-4 text-lg text-white">
          <p>{$isLoading ? "Loading..." : $textToSpeak}</p>
        </div>
      {/if}
    </div>
  </Sidebar.Inset>
</Sidebar.Provider>

<style>
  .page-wrapper {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    height: 85vh;
    padding: 20px;
  }

  .visualizer {
    position: relative;
    width: 300px;
    height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    background: radial-gradient(circle, #1f2937, #4c1d95);
    box-shadow: 0 0 30px rgba(76, 29, 149, 0.8);
    transition: transform 0.5s ease-in-out;
    margin-bottom: 20px;
  }

  .center-circle {
    width: 100px;
    height: 100px;
    background: linear-gradient(135deg, #ffffff, #7c3aed);
    border-radius: 50%;
    animation: pulse 2s infinite ease-in-out;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
  }

  @keyframes pulse {
    0%,
    100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
    }
  }

  .subtitles {
    text-align: center;
    font-style: italic;
    color: rgba(255, 255, 255, 0.8);
  }

  .input-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: auto;
    position: sticky;
    bottom: 0;
  }

  input {
    flex: 1;
    padding: 10px;
    border-radius: 10px;
    border: 1px solid #ccc;
  }

  button {
    cursor: pointer;
  }
</style>
